## 迭代器与生成器

- 理解迭代
- 迭代器模式
- 生成器

### 7.1 理解迭代

循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循
环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。 

迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历
到，特别是开始和结束项有明确的定义。）数组是 JavaScript中有序集合的最典型例子。 

因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。
由于如下原因，通过这种循环来执行例程并不理想。 

- 迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，
  然后再通过`[]`操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。 
- 遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适
  用于其他具有隐式顺序的数据结构。 

ES5新增了 `Array.prototype.forEach()`方法，向通用迭代需求迈进了一步（但仍然不够理想）：

```javascript
let collection = ['foo', 'bar', 'baz']; 

collection.forEach((item) => console.log(item)); 
// foo 
// bar 
// baz 
```

这个方法解决了单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止。
因此这个方法只适用于数组，而且回调结构也比较笨拙。 

在 ECMAScript较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现
迭代操作。这个解决方案就是迭代器模式。

### 7.2 迭代器模式

迭代器模式（特别是在 ECMAScript这个语境下）描述了一个方案，即可以把有些结构称为“可迭
代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。 

可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对
象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序： 

```javascript
// 数组的元素是有限的 
// 递增索引可以按序访问每个元素 
let arr = [3, 1, 4]; 

// 集合的元素是有限的 
// 可以按插入顺序访问每个元素 
let set = new Set().add(3).add(1).add(4); 
```

迭代器（iterator）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。

#### 7.2.1 可迭代协议

实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现
Iterator 接口的对象的能力。在 ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器” ，而
且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂
函数，调用这个工厂函数必须返回一个新迭代器。 

很多内置类型都实现了 Iterable 接口： 

- 字符串 
- 映射 
- 集合 
- arguments 对象 
- NodeList 等 DOM集合类型

原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器： 

```javascript
let arr = ['foo', 'bar', 'baz']; 

// for-of 循环 
for (let el of arr) { 
  console.log(el); 
}

// foo 
// bar 
// baz 

// 数组解构 
let [a, b, c] = arr; 
console.log(a, b, c); // foo, bar, baz 

// 扩展操作符 
let arr2 = [...arr]; 
console.log(arr2); // ['foo', 'bar', 'baz'] 

// Array.from() 将类数组结构转换为数组实例
let arr3 = Array.from(arr); 
console.log(arr3); // ['foo', 'bar', 'baz'] 

// Set 构造函数 
let set = new Set(arr); 
console.log(set); // Set(3) {'foo', 'bar', 'baz'} 

// Map 构造函数 
let pairs = arr.map((x, i) => [x, i]); 
console.log(pairs); // [['foo', 0], ['bar', 1], ['baz', 2]] 
let map = new Map(pairs); 
console.log(map); // Map(3) { 'foo'=>0, 'bar'=>1, 'baz'=>2 } 
```


