## 集合引用类型

- 对象
- 数组与定型数组
- Map、WeakMap、Set以及WeakSet类型

### 6.1 Object

显式地创建 `Object` 的实例有两种方式。第一种是使用 `new` 操作符和 `Object` 构造函数， 如下所示：  

```javascript
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29; 
```

另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是
为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 `person` 对象，但使
用的是对象字面量表示法： 

```javascript
let person = {  
  name: "Nicholas", 
  age: 29 
}; 
```

在对象字面量表示法中，属性名也可以是字符串或者数值。之后我们会更加详细地介绍`Object`类型。

### 6.2 Array

注意，数组和其他编程语言的数组有很大区别。其主要不同有两点：

- 数组中可以存储任意的数据。这意味着一个数组第一个元素可以是字符串，第二个元素是数值。
- 数组是动态大小，会随着数据添加而自动增长。即使索引越界也可以正常工作。

```javascript
let arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

#### 6.2.1 创建数组

```javascript
//构造函数

let colors = new Array(); 

//可以传入参数length

let colors = new Array(20); 

//也可以传入要保存的元素

let colors = new Array("red", "blue", "green"); 

//以上，省略new的效果也一样

//也可以使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表

let colors = ["red", "blue", "green"]; 
```

**注意**，ES6新增关于数组的两个构造函数：`Array.from()`和`Array.of()`。`from()`用于将类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。 `Array.from()`的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 `length` 属性和可索引元素的结构。这种方式可用于很多场合： 

```javascript
// 字符串会被拆分为单字符数组 
console.log(Array.from("Matt")); // ["M", "a", "t", "t"]

// Array.from()对现有数组执行浅复制 
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1); 

console.log(a1);        // [1, 2, 3, 4] 
alert(a1 === a2); // false 



// 可以使用任何可迭代对象 
const iter = { 
  *[Symbol.iterator]() { 
    yield 1; 
    yield 2; 
    yield 3; 
    yield 4; 

  } 
}; 
console.log(Array.from(iter)); // [1, 2, 3, 4] 

// arguments 对象可以被轻松地转换为数组 
function getArgsArray() { 
  return Array.from(arguments); 
} 
console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4] 

// from()也能转换带有必要属性的自定义对象 
const arrayLikeObject = { 
  0: 1, 
  1: 2, 
  2: 3, 
  3: 4, 
  length: 4 
}; 
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4] 
```

`Array.from()`还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像
调用 `Array.from().map()`那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函
数中 `this` 的值。但这个重写的 `this` 值在箭头函数中不适用。 

```javascript
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1, x => x**2); 
const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2}); 
console.log(a2);  // [1, 4, 9, 16] 
console.log(a3);  // [1, 4, 9, 16] 
```

`Array.of()`可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的`Array.prototype.` 
`slice.call(arguments)`，一种异常笨拙的将 `arguments` 对象转换为数组的写法： 

```javascript
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] 
console.log(Array.of(undefined));  // [undefined] 
```

#### 6.2.2 数组空位

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间
相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位。

ES6 新增的方法和迭代器与早期 ECMAScript 版本中存在的方法行为不同。ES6 新增方法普遍将这
些空位当成存在的元素，只不过值为 `undefined`： 

```javascript
const options = [1,,,,5]; 

for (const option of options) { 
  console.log(option === undefined);  
} 
// false 
// true 
// true 
// true 
// false 

const a = Array.from([,,,]); // 使用 ES6 的 Array.from()创建的包含3 个空位的数组 
for (const val of a) { 
  alert(val === undefined); 
} 
// true 
// true 
// true 

alert(Array.of(...[,,,])); // [undefined, undefined, undefined] 

for (const [index, value] of options.entries()) { 
  alert(value); 
} 
// 1 
// undefined 
// undefined 
// undefined 
// 5 
```

ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异： 

```javascript
const options = [1,,,,5]; 

// map()会跳过空位置 
console.log(options.map(() => 6));  // [6, undefined, undefined, undefined, 6] 

// join()视空位置为空字符串 
console.log(options.join('-'));     // "1----5" 
```

我们实践中要避免使用数组空位，如果确实需要空位，可以显式用undefined值来代替。

#### 6.2.3 数组索引

正如开头所讲，数组索引与其他编程语言有很大不同。数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素。

#### 6.2.4 检测数组 和 6.2.6 复制和填充方法

略

#### 6.2.5 迭代器方法

在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：`keys()`、`values()`和
`entries()`。`keys()`返回数组索引的迭代器，`values()`返回数组元素的迭代器，而 `entries()`返回
索引/值对的迭代对象，该对象包含数组的键值对 (key/value)： 

```javascript
const a = ["foo", "bar", "baz", "qux"]; 

// 因为这些方法都返回迭代器，所以可以将它们的内容 
// 通过 Array.from()直接转换为数组实例 
const aKeys = Array.from(a.keys()); 
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries()); 

console.log(aKeys);     // [0, 1, 2, 3] 
console.log(aValues);   // ["foo", "bar", "baz", "qux"] 
console.log(aEntries);  // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]] 
```

使用 ES6的解构可以非常容易地在循环中拆分键/值对： 

```javascript
const a = ["foo", "bar", "baz", "qux"]; 

for (const [idx, element] of a.entries()) { 
  alert(idx);  
  alert(element); 
} 
// 0 
// foo 
// 1 
// bar 
// 2 
// baz 
// 3 
// qux 
```

#### 6.2.7 转换方法

前面提到过，所有对象都有`toLocaleString()`、`toString()`和`valueOf()`方法。其中，`valueOf()`返回的还是数组本身。而 `toString()`返回由数组中每个值的等效字符串拼接而成的一个**逗号分隔**的字符串。也就是说，对数组的每个值都会调用其 `toString()`方法，以得到最终的字符串。来看下面的例子： 

```javascript
let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组 
alert(colors.toString());   // red,blue,green 
alert(colors.valueOf());    // red,blue,green 
alert(colors);              // red,blue,green 
```

`toLocaleString()`方法也可能返回跟 `toString()`和 `valueOf()`相同的结果，但也不一定。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的 `toLocaleString()`方法，而不是`toString()`方法。

以上都返回数组值的逗号分隔的字符串，如果想使用**不同的分隔符**，则可以使用 `join()`方法。

#### 6.2.8 栈方法

栈是一种后进先出的数据结构，可以使用`push()`和 `pop()`方法，以实现类似栈的行为。

#### 6.2.9 队列方法

队列是先进先出的数据结构，可以使用`shift())`和 `push()`，把数组当成队列来使用。`shift()`会删除数组的第一项并返回它，然后数组长度减 1。ECMAScript也为数组提供了 `unshift()`方法。顾名思义，`unshift()`就是执行跟 `shift()`相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 `unshift()`和 `pop()`，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据。

#### 6.2.10 排序方法

顾名思义，`reverse()`方法就是将数组元素反向排列。

默认情况下，`sort()`会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，
sort()会在每一项上调用 `String()`转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。比如： 

```javascript
let values = [0, 1, 5, 10, 15]; 
values.sort(); 
alert(values);  // 0,1,10,15,5 
```

即使 5小于 10，但字符串"10"在字符串"5"的前头，所以 10还是会排到 5前面。很明显，这在多数情
况下都不是最合适的。为此，`sort()`方法可以接收一个比较函数，用于判断哪个值应该排在前面。 

比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相
等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一
个例子： 

```javascript
function compare(value1, value2) { 
  if (value1 < value2) { 
    return -1; 
  } else if (value1 > value2) { 
    return 1; 
  } else {  
    return 0; 
  } 
} 
```

这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 sort()方法，如下所示： 

```javascript
let values = [0, 1, 5, 10, 15]; 
values.sort(compare); 
alert(values);  // 0,1,5,10,15 
```

在给 `sort()`方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也
可以产生降序效果，只要把返回值交换一下即可。

此外，这个比较函数还可简写为一个箭头函数： 

```javascript
let values = [0, 1, 5, 10, 15]; 
values.sort((a, b) => a < b ? 1 : a > b ? -1 : 0); 
alert(values); // 15,10,5,1,0 
```

在这个修改版函数中，如果第一个值应该排在第二个值后面则返回 1，如果第一个值应该排在第二
个值前面则返回-1。交换这两个返回值之后，较大的值就会排在前头，数组就会按照降序排序。当然，如果只是想反转数组的顺序，`reverse()`更简单也更快。 

**注意**  `reverse()`和 `sort()`都返回调用它们的数组的引用。 

如果数组的元素是数值，或者是其 `valueOf()`方法返回数值的对象（如 `Date` 对象），这个比较函
数还可以写得更简单，因为这时可以直接用第二个值减去第一个值： 

```javascript
function compare(value1, value2){ 
  return value2 - value1;  
} 
```

比较函数就是要返回小于 0、0和大于 0的数值，因此减法操作完全可以满足要求。 

#### 6.2.11 操作方法

`concat()`方法连接两个数组，`slice()`方法做数组的切片，还有一个最强大的操作方法`splice()`，它可以删除、插入和替换。建议需要使用时参考。

#### 6.2.12 搜索和位置方法

ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。 

##### 6.2.12.1 严格相等

`indexOf()`、`lastIndexOf()`和 `includes()`，其中第三个是ES7新增，这些方法都接收两个参
数：要查找的元素和一个可选的起始搜索位置。`indexOf()`和 `includes()`方法从数组前头（第一项）开始向后搜索，而 `lastIndexOf()`从数组末尾（最后一项）开始向前搜索。

`indexOf()`和 `lastIndexOf()`都返回要查找的元素在数组中的位置，如果没找到则返回-1。
`includes()`返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一
项时，会使用全等（===）比较，也就是说两项必须严格相等。下面来看一些例子： 

```javascript
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 

alert(numbers.indexOf(4));          // 3 
alert(numbers.lastIndexOf(4));      // 5 
alert(numbers.includes(4));         // true 

alert(numbers.indexOf(4, 4));       // 5 
alert(numbers.lastIndexOf(4, 4));   // 3 
alert(numbers.includes(4, 7));      // false 

let person = { name: "Nicholas" }; 
let people = [{ name: "Nicholas" }]; 
let morePeople = [person]; 

alert(people.indexOf(person));      // -1 
alert(morePeople.indexOf(person));  // 0 
alert(people.includes(person));     // false 
alert(morePeople.includes(person)); // true 
```

##### 6.2.12.2 断言函数

`find()`和 `findIndex()`方法使用了断言函数。这两个方法都从数组的最小索引开始。`find()`返回
第一个匹配的元素， `findIndex()`返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。 

```javascript
const people = [  
  { 
    name: "Matt", 
    age: 27 
  }, 
  { 
    name: "Nicholas", 
    age: 29 
  } 
]; 

alert(people.find((element, index, array) => element.age < 28)); 
// {name: "Matt", age: 27} 

alert(people.findIndex((element, index, array) => element.age < 28)); 
// 0 
```

找到匹配项后，这两个方法都不再继续搜索。 

#### 6.2.13 迭代方法

ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。数组的 5个迭代方法如下。 

- `every()`： 对数组每一项都运行传入的函数，如果对每一项函数**都**返回true， 则这个方法返回true。
- `filter()`：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。 
- `forEach()`：对数组每一项都运行传入的函数，没有返回值。 
- `map()`：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。 
- `some()`：对数组每一项都运行传入的函数，**只要有一项**函数返回 true，则这个方法返回 true。

这些方法都不改变调用它们的数组。

#### 6.2.14 归并方法

`reduce()`和 `reduceRight()`，这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。`reduce()`方法从数组第一项开始遍历到最后一项。而 `reduceRight()`从最后一项开始遍历至第一项。

可以使用 `reduce()`函数执行累加数组中所有数值的操作，比如： 

```javascript
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduce((prev, cur, index, array) => prev + cur); 

alert(sum);  // 15 


```

### 6.3 定型数组

在之后进行详细说明。

### 6.4 Map

#### 6.4.1 基本API

ES 6以前，在 JavaScript中实现“键/值”式存储可以使用 Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。作为 ES 6的新增特性，`Map` 是一种新的集合类型，为这门语言带来了真正的键/值存储机制。

初始化之后，可以使用 `set()`方法再添加键/值对。另外，可以使用 `get()`和 `has()`进行查询，可
以通过 `size` 属性获取映射中的键/值对的数量，还可以使用 `delete()`和 `clear()`删除值。 

与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用**任何** JavaScript数据类型作为
键。

#### 6.4.2 顺序与迭代

与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执
行迭代操作。 
映射实例可以提供一个迭代器（Iterator），能以插入顺序生成`[key, value]`形式的数组。可以
通过 `entries()`（c.f. 6.2.5，`entries()` 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)）方法（或者 `Symbol.iterator` 属性，它引用 `entries()`）取得这个迭代器： 

```javascript
const m = new Map([ 
  ["key1", "val1"],  
  ["key2", "val2"], 
  ["key3", "val3"] 
]); 

alert(m.entries === m[Symbol.iterator]); // true 
```

>  es6中有三类结构生来就具有Iterator接口：数组、类数组对象、Map和Set结构。

> 类数组对象指的是并非由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为"类数组对象"

```javascript
for (let pair of m.entries()) { 
  alert(pair); 
} 
// [key1,val1] 
// [key2,val2] 
// [key3,val3] 

for (let pair of m[Symbol.iterator]()) { 
  alert(pair); 
} 
// [key1,val1] 
// [key2,val2] 
// [key3,val3] 
```

因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组： 

```javascript
const m = new Map([ 
  ["key1", "val1"], 
  ["key2", "val2"], 
  ["key3", "val3"] 
]); 

console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]] 
```

> 三个点（...）真名叫扩展运算符，是在ES6中新增加的内容，它可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开；还可以在构造字面量对象时将对象表达式按照key-value的方式展开。可以简单理解为去掉其后面形式跟着的大括号（[]）、花括号（{}）等等各种矫饰。

```javascript
console.log([m]); //Map(3)
```

`keys()`和 `values()`分别返回以插入顺序生成键和值的迭代器：

```javascript
const m = new Map([  
  ["key1", "val1"], 
  ["key2", "val2"], 
  ["key3", "val3"] 
]); 

for (let key of m.keys()) { 
  alert(key); 
} 
// key1 
// key2 
// key3 

for (let value of m.values()) { 
  alert(value); 
} 
// value1 
// value2 
// value3 
```

#### 6.4.3 选择Object 还是 Map

从内存占用、插入性能、删除性能来说都是Map更强一些，如果代码涉及大量查找，某些时候选择Object更好一些。

### 6.5 WeakMap

#### 6.5.1 基本API

可以使用 new 关键字实例化一个空的 WeakMap： 

```
const wm = new WeakMap(); 
```

弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出
TypeError。值的类型没有限制。 如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中： 

```javascript
const key1 = {id: 1}, 
      key2 = {id: 2},  
      key3 = {id: 3}; 

// 使用嵌套数组初始化弱映射 
const wm1 = new WeakMap([ 
  [key1, "val1"], 
  [key2, "val2"], 
  [key3, "val3"] 
]); 
alert(wm1.get(key1)); // val1 
alert(wm1.get(key2)); // val2 
alert(wm1.get(key3)); // val3 

// 初始化是全有或全无的操作 
// 只要有一个键无效就会抛出错误，导致整个初始化失败 
const wm2 = new WeakMap([ 
  [key1, "val1"], 
  ["BADKEY", "val2"], 
  [key3, "val3"] 
]); 
// TypeError: Invalid value used as WeakMap key 
typeof wm2; 
// ReferenceError: wm2 is not defined 
```

初始化之后可以使用 `set()`再添加键/值对，可以使用 `get()`和 `has()`查询， 还可以使用 `delete()`
删除。

#### 6.5.2 弱键

WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”（weakly held）的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。 

```javascript
const wm = new WeakMap(); 

wm.set({}, "val"); 
```

`set()`方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，
所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失
了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身
也会成为垃圾回收的目标。 再看一个例子：

```javascript
const wm = new WeakMap(); 

const container = { 
  key: {}  
}; 

wm.set(container.key, "val"); 

function removeReference() { 
  container.key = null; 
} 
```

这一次，`container` 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目
标。不过，如果调用了 `removeReference()`，就会摧毁键对象的最后一个引用，垃圾回收程序就可以
把这个键/值对清理掉。 

#### 6.5.3 不可迭代键

因为 WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。

#### 6.5.4 使用策略

因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中
使用了常规的 Map： 

```javascript
const m = new Map();  

const loginButton = document.querySelector('#login'); 

// 给这个节点关联一些元数据 
m.set(loginButton, {disabled: true}); 
```

假设在上面的代码执行后，页面被 JavaScript 改变了，原来的登录按钮从 DOM 树中被删掉了。但
由于映射中还保存着按钮的引用，所以对应的 DOM节点仍然会逗留在内存中，除非明确将其从映射中
删除或者等到映射本身被销毁。 

如果这里使用的是弱映射，如以下代码所示，那么当节点从 DOM树中被删除后，垃圾回收程序就
可以立即释放其内存（假设没有其他地方引用这个对象）： 

```javascript
const wm = new WeakMap(); 

const loginButton = document.querySelector('#login'); 

// 给这个节点关联一些元数据 
wm.set(loginButton, {disabled: true}); 
```

### 6.6 Set

#### 6.6.1 基本API

使用 `new` 关键字和 `Set` 构造函数可以创建一个空集合： 

```javascript
const m = new Set(); 
// Initialize set with array
const s1 = new Set(["val1", "val2", "val3]);
```

初始化之后，可以使用`add()`增加值， 使用`has()`查询， 通过`size` 取得元素数量，以及使用`delete()`和 `clear()`删除元素。

**注意：**`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。重复元素在`Set`中自动被过滤：

```javascript
let s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, "3"}
```

#### 6.6.2 顺序与迭代

Set 会维护值插入时的顺序，因此支持按顺序迭代。 

集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 `values()`方
法及其别名方法 `keys()`（或者 `Symbol.iterator` 属性，它引用 `values()`）取得这个迭代器： 

```javascript
const s = new Set(["val1", "val2", "val3"]); 

alert(s.values === s[Symbol.iterator]); // true 
alert(s.keys === s[Symbol.iterator]);   // true 

for (let value of s.values()) { 
  alert(value);  
} 
// val1 
// val2 
// val3 

for (let value of s[Symbol.iterator]()) { 
  alert(value); 
} 
// val1 
// val2 
// val3 
```

### 6.7 WeakSet

略

### 6.8 迭代与扩展操作 

在接下来的章节会详细介绍。

### 6.9 小结

JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。 

- 引用类型与传统面向对象编程语言中的类相似，但实现不同。 
- Object 类型是一个基础类型，所有引用类型都从它继承了基本的行为。 
- Array 类型表示一组有序的值，并提供了操作和转换值的能力。 
-  定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。 
- Date 类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。 
- RegExp 类型是 ECMAScript支持的正则表达式的接口，提供了大多数基本正则表达式以及一些
  高级正则表达式的能力。 

JavaScript 比较独特的一点是，函数其实是 Function 类型的实例，这意味着**函数也是对象**。由于
函数是对象，因此也就具有能够增强自身行为的方法。 

因为原始值包装类型的存在，所以 JavaScript中的原始值可以拥有类似对象的行为。有 3种原始值
包装类型：Boolean、Number 和 String。它们都具有如下特点。 

- 每种包装类型都映射到同名的原始类型。 
- 在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。 
- 涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。 

JavaScript 还有两个在一开始执行代码时就存在的内置对象：`Global` 和 `Math`。其中，`Global` 对
象在大多数 ECMAScript实现中无法直接访问。不过浏览器将 `Global` 实现为 `window` 对象。所有全局
变量和函数都是 `Global` 对象的属性。`Math` 对象包含辅助完成复杂数学计算的属性和方法。


ECMAScript 6新增了一批引用类型：`Map`、`WeakMap`、`Set` 和 `WeakSet`。这些类型为组织应用程序
数据和简化内存管理提供了新能力。 