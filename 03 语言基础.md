## 语言基础

### 3.1 语法

#### 3.1.1 区分大小写

#### 3.1.2 标识符

- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。

按照惯例，ECMAScript标识符采用**驼峰大小写**格式，也就是第一个字母小写，剩下的每个单词的首字母大写，例如： `firstSecond`、`myCar`、`doSomethingImportant`。

#### 3.1.3 注释


```
// 单行注释 
 
块级注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾。同CSS。
```

#### 3.1.4 严格模式 

ECMAScript 5引入了严格模式（strict mode）的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全
的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 
 
```
"use strict";
```

#### 3.1.5 语句

- 分号并非必要但是推荐。没有分号只能由解析器决定语句何时结束。
- 多条语句可以合并到C语言风格的代码块中，代码块由一个左括号`{`开始，以右括号`}`结束。推荐类似if语句这样的控制语句都使用代码块。

### 3.2 关键字和保留字 

略

### 3.3 变量 

ECMAScript 的变量是**松散类型**的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。

有 3 个关键字可以声明变量：`var`、`const` 和 `let`。其中，`var` 在
ECMAScript的所有版本中都可以使用，而 `const` 和 `let` 只能在 ECMAScript 6及更晚的版本中使用。 

#### 3.3.1 var声明

定义变量时要使用`var`操作符（注意var是一个关键字），后跟变量名（即一个标识符），如下所示： 
 
```
var message;
```

这行代码定义了一个名为 `message` 的变量，可以用它保存任何类型的值。（不初始化的情况下，变量会保存一个特殊值 `undefined`）
```
var message = "hi"; 
message = 100;  // 合法，但不推荐 
```
这意味着可以改变它的值。

##### 3.3.1.1 声明作用域

使用`var`声明的变量是局部变量，而省略掉`var`这使得该变量成为全局变量。虽然可以通过省略这个途径定义全局变量，但不推荐这么做，在局部作用域中定义全局变量很难维护，且容易造成误会。

##### 3.3.1.1.2 声明提升
```
function foo() {  
  console.log(age); 
  var age = 26; 
} 
foo();  // undefined 
```
之所以不会报错，是因为ECMAScript运行时把它看成等价于如下代码： 
```
function foo() { 
  var age; 
  console.log(age); 
  age = 26; 
} 
foo();  // undefined 
```
这就是所谓的**提升**（hoist），也就是把所有变量声明都拉到函数作用域的顶部。

#### 3.3.2 let声明

##### 3.3.2.1 作用域

`let`定义变量和`var`一样，但是它们之间有许多不同。最显著的一点不同即let声明的变量是**块作用域**（block scope），而var是**函数作用域**（function scope）。
```
if (true) { 
  var name = 'Matt'; 
  console.log(name); // Matt 
} 
console.log(name);   // Matt 
```
```
if (true) { 
  let age = 26; 
  console.log(age);   // 26 
} 
console.log(age);     // ReferenceError: age 没有定义 
```
##### 3.3.2.2 变量提升

而另外一个重点不一样的就是，`let`不允许变量提升（assuming hoisting）

```
// name is hoisted
console.log(name);  // undefined
var name = 'Matt';
 
// age is not hoisted
console.log(age);  // ReferenceError: age is not defined
let age = 26; 
```

##### 3.3.2.3 绑定对象

第三点不同即在全局声明变量时，`let`声明的变量不会类似`var`一样和`window`对象绑定。
```
var name = 'Matt';
console.log(window.name);  // 'Matt'
 
let age = 26;
console.log(window.age);   // undefined 
```

但是`let`声明仍然存在于全局作用域中，一直持续到页面销毁。因为为了避免SyntaxError，我们必须确保**不要重复声明**。

##### 3.3.2.4 暂时性死区

只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

```
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```
上面代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。

“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
```
typeof x; // ReferenceError
let x;
```
上面代码中，变量`x`使用`let`命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，`typeof`运行时就会抛出一个ReferenceError。

##### 3.3.2.5 for循环计数器

对于loops循环中的let声明也有所不同，`let`声明的变量只在循环块中生效。比如：
```
for (let i = 0; i < 5; ++i) {
  // do loop things
}
console.log(i);  // ReferenceError: i is not defined
```

我们用`var`的时候最费解的莫过于迭代变量的改变（modification of iterator variable），会渗透到循环体外部，如下所示：
```
for (var i = 0; i < 5; ++i) {
  setTimeout(() => console.log(i), 0)
}
// You might expect this to console.log 0, 1, 2, 3, 4
// It will actually console.log 5, 5, 5, 5, 5
// setTimeout(函数,时间)指每隔多少时间执行函数。
```

这是因为变量`i`渗透到了循环体外部（`var`声明的变量是函数作用域），所以在退出循环时，迭代变量保存的始终是最终导致退出循环的值。而改用`let`之后，这个问题便消失了因为JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。

---

总结不同：
- 作用域不同。
- 无法变量提升。
- 在块级作用域内，let声明变量前会有一个暂时性死区。
- 全局声明时不与window对象绑定。
- let定义迭代变量时不会渗透到循环外部。

---

#### 3.3.3 const

和C++ `const`类似。`const`声明的限制只适用于它指向的变量的引用。换句话说，如果`const`变量引用的是一个对象，那么修改这个对象内部的属性并不违反 `const` 的限制。 
```
const person = {}; 
person.name = 'Matt';  // ok 
```

#### 3.3.4 声明风格最佳实践

- 不使用var。
- const优先，let次之。

### 3.4 数据类型 

- Undefined
- Null
- Boolean
- Number
- String
- ES6中新增的Symbol
- Object

前面六种被称为**简单数据类型**，也被称之为**原始类型**。

#### 3.4.1  typeof操作符 

鉴于 ECMAScript是松散类型的，因此需要有一种手段来检测给定变量的数据类型——`typeof`就是负责提供这方面信息的操作符。对一个值使用`typeof`操作符可能返回下列某个**字符串**：
- 返回除开Object和Null数据类型本身的数据类型名称，如返回Number。
- 返回`object`字符串时，这个值是对象**或者**Null。
- 返回`function`字符串时，这个值是函数。

#### 3.4.2  Undefined类型 

`Undefined`类型只有一个值，即特殊的**undefined**。在使用 `var`和`let`声明变量但未对其加以初始化时，这个变量的值就是`undefined`，例如： 
``` 
var message; 
alert(message == undefined); //true 
```

即便未初始化的变量会自动被赋予`undefined`值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 `typeof`操作符返回`undefined`值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。 

#### 3.4.3  Null类型 

从逻辑角度来看，**null值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因**。

注意，undefined的值是由null值衍生而来，所以它们表面相等。
```
console.log(null == undefined);  // true 
```

**建议**：我们永远不必显式地将变量设置为`undefined`。但是`null`不是这样的。任何时候，只要变量保存对象，而当时又没有那个对象可供保存，就要用`null`来填充变量。

#### 3.4.4  Boolean类型 


- 该类型只有两个字面值：true 和 false。
这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0。
- 需要注意的是， Boolean 类型的字面值 true 和 false 是**区分大小写**的。也就是说，True和False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。 

#### 3.4.5  Number类型 

##### 3.4.5.1 基本数字类型

- 八进制的第一个数字必须是0。
- 十六进制的数值前缀 0x（区分大小写）。
- 注意浮点数的陷阱，别轻易将浮点数做比较。
```
let a = 0.1,
    b = 0.2;
if (a + b == 0.3) {      // 别这么干！   
  console.log("You got 0.3."); 
}
//注意，结果不会输出任何信息。
```

##### 3.4.5.2 非数值类型

- **NaN**，即非数值（Not a  Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。
- 在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMAScript中，0除以0会返回NaN，因此不会影响其他代码的执行。 （其他时候正数除以0返回 Infinity，负数除以0返回-Infinity。）

##### 3.4.5.3 数值转换

有 3个函数可以将非数值转换为数值：`Number()`、`parseInt()`和 `parseFloat()`。`Number()`是
转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个
函数执行的操作也不同。 

- `Number()`的转换非常简单，布尔值、数值略过不提，null将返回0，而undefined则返回`NaN`，如果字符串中包含数值则直接返回数值，如果是空字符串返回0，如果非以上情况则返回`NaN`。
- `parseInt()`只要第一个字符不是数值字符或者加减号，立刻返回`NaN`。即使是空字符串也是如此。其提供第二个参数可以指定底数（进制数）以便于更好编译。
```
let num1 = parseInt("AF", 16);  // 175 
let num2 = parseInt("AF");      // NaN 
// 第二个转换遇到的是非加减字符或数值字符。
```
- 为了避免建议出错，`parseInt()`建议始终给定第二个参数。
- `parseFloat()`始终忽略字符串开头的0，并且只用于解析十进制。十六进制数值始终返回0。


#### 3.4.6  String类型 

字符串可以由双引号（"）或单引号（'）表示。

##### 3.4.6.1 ES6新特性字符串模板

ES6中定义超过一行的文字可以使用类似MARKDOWN的语法`字符串包裹。

```
let myMultiLineString = 'first line\nsecond line';
let myMultiLineTemplateLiteral = `first line
second line`;
 
console.log(myMultiLineString);  
// first line
// second line"
 
console.log(myMultiLineTemplateLiteral);   
// first line
// second line
 
console.log(myMultiLineString === myMultiLinetemplateLiteral);   // true
```

如同它的名字暗示的，它最适合用于定义模板，比如大段的HTML语句。

##### 3.4.6.2 interpolation 字符串插值

可以更方便地插入文字，使用方法：`${表达式}`。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。

```
let value = 5;
let exponent = 'second';
 
// Formerly, interpolation was accomplished as follows:
let interpolatedString = 
  value + ' to the ' + exponent + ' power is ' + (value * value);
 
 // The same thing accomplished with template literals:
let interpolatedTemplateLiteral = 
  `${ value } to the ${ exponent } power is ${ value * value }`;
 
console.log(interpolatedString);           // 5 to the second power is 25
console.log(interpolatedTemplateLiteral);  // 5 to the second power is 25
```

##### 3.4.6.3 标签模板

待补充。

##### 3.4.6.4 原生字符串

有关字符串模板的原声字符串问题：

```
// Unicode demo
// \u00A9 is the copyright symbol
console.log(`\u00A9`);            // ©
console.log(String.raw`\u00A9`);  // \u00A9
 
// Newline demo
console.log(`first line\nsecond line`);            
// first line
// second line
 
console.log(String.raw`first line\nsecond line`);  // "first line\nsecond line"
```

#### 3.4.7 Symbol

ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6引入`Symbol`的原因。

ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。

Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。
```
let s = Symbol();

typeof s
// "symbol"
```
上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。

Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
```
let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // "Symbol(foo)"
s2.toString() // "Symbol(bar)"
```
上面代码中，`s1`和`s2`是两个Symbol值。如果不加参数，它们在控制台的输出都是`Symbol()`，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。

其他更多内容详见有关于symbol的补充。

#### 3.4.8 object类型

ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建
的对象类型的名称来创建。而创建`Object` 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示： 
```
var o = new Object(); 
```

之后我们将详细介绍对象。

### 3.5 操作符

#### 3.5.1 一元操作符

执行**前置**递增和递减操作时，变量的值都是在语句**被求值以前改变**的。（在计算机科学领域，这种情况通常被称作副效应。）请看下面这个例子。 

```
let age = 29; 
let anotherAge = --age + 2; 
 
console.log(age);         // 28 
console.log(anotherAge);  // 30 
```

后置递增和递减操作是在包含它们的语句**被求值之后**才执行的。
```
let num1 = 2; 
let num2 = 20; 
let num3 = num1-- + num2; 
let num4 = num1 + num2; 
console.log(num3);  // 22 
console.log(num4);  // 21 
```

#### 3.5.2 位操作符

##### 3.5.2.1 二进制补码和反码

对于有符号的整数，，32位中的前31位用于表示整数的值。第 32位用于表示数值的符号：0表示正数，1 表示负数。这个表示符号的位叫做符号位。

比如18的二进制表达为10010。为了求-18的二进制，我们要使用**二进制补码**。

1. 求这个数字的二进制码。
2. 求二进制反码，即0替换成1，1替换成0。
3. 得到的二进制反码加1。

不过计算机会帮我们尽量处理这些信息，所以如果我们用：
```
var num = -18; 
alert(num.toString(2));    // "-10010" 
```
得到的结果仍然是18的二进制前面加上了一个负号。

##### 3.5.2.2 非、与、或、异或、左右移

非值用波浪符（~）表示，等于直接将原数字二进制取反码，最终效果是数字取反减1。与操作符用和号（&）表示，位数都为1是为1，否则为0，或操作用管道符（|）表示，则是都为0时为0，否则为1。异或即相同为0，不同为1。用插入符号（^）表示。

左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。左移操作会以 0来填充这些空位。右移不赘述。无符号右移会把第一位的符号位也右移动，所以可能会变成一个很大的值。

#### 3.5.3 布尔操作符
#### 3.5.4 乘性操作符
#### 3.5.5 加法操作符
#### 3.5.6 关系操作符
#### 3.5.7 相等操作符

`==`和`===`号之间有很大的差别，使用`==`时，编译器会自动转换数据类型再进行比较，往往会得到一些怪异的结果。比如说`false==0；`这个语句，输出结果为真。但往往我们希望是两个相同类型的值作比较，所以我们提倡使用`===`号。

#### 3.5.8 条件操作符
#### 3.5.9 赋值操作符
#### 3.5.10 逗号操作符

逗号操作符可以用来在一条语句中执行多个操作。

### 3.6语句

#### 3.6.1-3.6.4

略

#### 3.6.5 for-in 语句 

`for-in` 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下： 
```
for (property in expression) statement 
```

#### 3.6.6 for-of 语句

`for-of` 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下： 
```
for (property of expression) statement 
```
下面是示例： 
```
for (const el of [2,4,6,8]) { 
  document.write(el); 
} 
```
在这个例子中，我们使用`for-of`语句显示了一个包含 4个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与for循环一样，这里控制语句中的 `const`也不是必需的。但为了确保这个局部变量不被修改，推荐使用`const`。 

#### 3.6.6-3.6.10

略

### 3.7 函数

在之后会进行详细介绍。