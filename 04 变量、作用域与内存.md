## 变量、作用域和内存问题

JavaScript 变量**松散类型**的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但JavaScript变量实际的复杂程度还远不止如此。 

- 松散类型：JavaScript、Python、Ruby
- 强类型：Java、C++、Go、Swift

### 4.1 原始值和引用值

ECMAScript变量可能包含两种不同数据类型的值：原始值（primitive）和引用类型值（reference）。

- 原始值指的是简单的数据段
- 而引用类型值指那些可能由多个值构成的对象。 

在将一个值赋给变量时，解析器必须确定这个值是原始值还是引用类型值。我们之前讨论的六种类型——Undefined、Null、Boolean、Number、String和Symbol值。它们都是基本数据类型，它们都是按值访问的，因为可以操作保存在变量中的实际的值。 

**注意**：在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。 

引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

#### 4.1.1 动态属性

- 对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。
- 不能给原始值添加属性，尽管这样做不会导致任何错误。（返回Undefined)

#### 4.1.2 复制变量值

- 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。这两个值占用的存储地方不同而且相互独立，互不干扰。
- 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区
  别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象。因此，改变其中一个变量，就会影响另一个变量。

#### 4.1.3 传递参数

- 在向参数传递原始值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments对象中的一个元素）。
- 在向参数传递引用类型的值时，会把这个**值在内存中的地址**复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。（这在 ECMAScript中是不可能的。）

**注意**：有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们来看一个例子：

```javascript
function setName(obj) {
  obj.name = "Nicholas";
  obj = new Object();
  obj.name = "Greg";
}
           
let person = new Object();
setName(person);
console.log(person.name);  // "Nicholas"
```

在把`person`传递给`setName()`后，其`name`属性被设置为"Nicholas"。然后，又将一个新对象赋给变量`obj`， 同时将其`name`属性设置为"Greg"。如果`person`是按引用传递的，那么`person`就会自动被修改为指向其`name`属性值为"Greg"的新对象。但是，当接下来再访问 `person.name`时，显示的值仍然是"Nicholas"。这说明即使在函数内部修改了参数的值，但原始引用仍然保持未变。这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。 

>  ECMAScript函数的参数就是局部变量。 

#### 4.1.4 检测数据类型

虽然在检测基本数据类型时`typeof`是非常得力的助手。但在检测引用类型的值时，这个操作符的用处不大。（记住，检测null和对象时都返回object）通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了`instanceof`操作符，其语法如下所示： 
```
result = variable instanceof constructor 
```

根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof 操作符始终会返回true。当然，如果使用instanceof 操作符检测原始值，则该操作符始终会返回 false，因为原始值不是对象。 

### 4.2 执行上下文和作用域

执行上下文（以下简称“上下文”）的概念在 JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。

全局上下文是最外层的上下文。根据 ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的window 对象。因此所有通过var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器） 。

上下文中的代码在执行的时候，会创建变量对象的一个**作用域链**（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。 （以后会详细说明）

>  注意 ：函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的
> 访问规则。 



#### 4.2.1 作用域链增强

执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有
其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时： 

- try/catch 语句的 catch 块 
- with 语句


这两种情况下，都会在作用域链前端添加一个变量对象。对 `with` 语句来说，会向作用域链前端添加指定的对象；对 `catch` 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子： 

```javascript
function buildUrl() {  
  let qs = "?debug=true"; 
 
  with(location){ 
    let url = href + qs; 
  } 
 
  return url; 
} 
```

#### 4.2.2 变量声明

##### 4.2.1.1 使用`var`的函数作用域声明

在使用 `var` 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函
数的局部上下文。在 `with` 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：

```javascript
function add(num1, num2) { 
  var sum = num1 + num2;  
  return sum; 
} 

let result = add(10, 20); // 30 
console.log(sum);         // 报错：sum 在这里不是有效变量 
```

显然变量`sum`在函数外部是访问不到的。如果省略掉`var`声明，则`sum`可以在函数外访问。（回忆`var`是函数作用域，`let`是块级作用域，但是省略掉声明，则变成全局。c.f. 3.3.1&3.3.2）

同时`var`有变量提升的功能。

##### 4.2.1.2 使用 `let` 的块级作用域声明

JavaScript 没有块级作用域经常会导致理解上的困惑。在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域（如果用ECMAScript的话来讲，就是它们自己的执行环境），因而支持根据条件来定义变量。例如，下面的代码在 JavaScript中并不会得到想象中的结果： 

```
if (true) { 
    var color = "blue"; 
} 
 
alert(color);    //"blue" 
```

这里是在一个 if 语句中定义了变量 color。如果是在 C、C++或 Java中，`color`会在if语句执行完毕后被销毁。但在 JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用 for 语句时尤其要牢记这一差异。

```javascript
for (var i = 0; i < 10; ++i) {} 
console.log(i); // 10 
 
for (let j = 0; j < 10; ++j) {} 
console.log(j); // ReferenceError: j 没有定义 
```

##### 4.2.1.3 使用`const`的常量声明

使用 `const` 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。 

##### 4.2.1.4 标识符查找

当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。 

### 4.3 垃圾回收

JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 C和 C++等
语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下
了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。 

#### 4.3.1 标记清理

JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数
内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。 

垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种） 。然后，它
会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。 

#### 4.3.2 引用计数

另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被
引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变
量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一
个值的引用数为 0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序
下次运行的时候就会释放引用数为 0的值的内存。 

这个方法很容易遇到循环引用的问题，所以现在不那么常用。

#### 4.3.3 性能

现代垃圾回收程序会基于对 JavaScript运行时环境的探测来决定何时运行。

#### 4.3.4 内存管理

将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫
作**解除引用**。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，如下面的例子所示： 

```javascript
function createPerson(name){  
  let localPerson = new Object(); 
  localPerson.name = name; 
  return localPerson; 
} 

let globalPerson = createPerson("Nicholas"); 

// 解除 globalPerson 对值的引用 

globalPerson = null; 
```

`globalPerson` 是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的。 

##### 4.3.4.1 通过 `const` 和 `let` 声明提升性能 

相比于使用`var`，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。

##### 4.3.4.2-4.3.4.4

意外声明全局变量是最常见但也最容易修复的内存泄漏问题。其他相关的问题可以看专业书籍讲解。

### 4.4 小结

JavaScript 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始数据类型
一：Undefined、Null、Boolean、Number、String 和 Symbol。原始值和引用值有以下特点。 

- 原始值大小固定，因此保存在栈内存上。 
- 从一个变量到另一个变量复制原始值会创建该值的第二个副本。 
- 引用值是对象，存储在堆内存上。 
- 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。 
- 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。
- `typeof` 操作符可以确定值的原始类型，而 `instanceof` 操作符用于确保值的引用类型。 

任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域） 。这个
上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结
如下。 

- 执行上下文分全局上下文、函数上下文和块级上下文。 
- 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。 
- 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文
  至全局上下文中的变量。 
- 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。 
- 变量的执行上下文用于确定什么时候释放内存。 

JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收
程序可以总结如下。 

- 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。 
- 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。 
- 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算
  法，但某些旧版本的 IE仍然会受这种算法的影响，原因是 JavaScript会访问非原生 JavaScript对
  象（如 DOM元素）。 
- 引用计数在代码中存在循环引用时会出现问题。 
- 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对
  象、全局对象的属性和循环引用都应该在不需要时解除引用。 

