## 基本引用类型

引用值（reference value）（或者对象）是某个特定引用类型的实例（instance）。在 ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”（classes）。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义（object definitions），因为它们描述了自己的对象应有的属性和方法。 

对象被认为是某个特定引用类型的实例。新对象通过使用`new` 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码： 

```javascript
let now = new Date(); 
```

这行代码创建了引用类型 Date 的一个新实例，并将它保存在变量 `now` 中。`Date()`在这里就是构
造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像 `Date` 这样的原
生引用类型，帮助开发者实现常见的任务。 

### 5.1 Date

#### 5.1.1 `Date.parse()`

`Date.parse()`方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。其支持的格式如下：

- “月/日/年” ，如"5/23/2019"； 
- “月名 日, 年”，如"May 23, 2019"； 
-  “周几 月名 日 年 时:分:秒 时区”，如"Tue May 23 2019 00:00:00 GMT-0700"； 
- ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ” ，如 2019-05-23T00:00:00（只适用于
  兼容 ES5的实现）。 

以下两条代码等价：

```javascript
let someDate = new Date(Date.parse("May 23, 2019")); 
let someDate = new Date("May 23, 2019"); 
```

这两行代码得到的日期也相同，这是因为后者会直接默认在后台调用`Date.parse()`。

#### 5.1.2 `Date.UTC()`

`Date.UTC()`方法也返回日期的毫秒表示，但使用的是跟 `Date.parse()`不同的信息来生成这个值。传给 `Date.UTC()`的参数是年、零起点月数（1月是 0，2月是 1，以此类推） 、日（1~31） 、时（0~23）、
分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1日。其他
参数的默认值都是 0。下面是使用 `Date.UTC()`的两个例子： 

```javascript
// GMT 时间 2000 年 1 月 1 日零点 
let y2k = new Date(Date.UTC(2000, 0)); 

// GMT 时间 2005 年 5 月 5 日下午 5 点 55 分55 秒 
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); 
```

#### 5.1.3 `data.now()`

表示现在的时间。

#### 5.1.4 继承的方法

`Date` 类型重写了 `toLocaleString()`、`toString()`和 `valueOf()`方法。

`toString()`方法返回带时区信息的日期和时间，现代浏览器它和`toLocaleString()`这两个方法的输出上已经趋于一致，这些差异实则表示往往更适合用于调试，而非显示。

而`valueOf()`方法根本不返回字符串，而是返回的日期的毫秒表示。因此操作符可以直接使用它返回的值。

至于`date（）`建议需要使用时再参考书籍或者网站了解。

### 5.2 RegExp

ECMAScript通过 `RegExp` 类型来支持正则表达式。使用下面类似 Perl的语法，就可以创建一个正则表达式。 

``` javascript
let expression = / pattern / flags ; 
```

也可以使用构造函数的形式来生成，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。由于`RegExp`构造函数的模式参数是字符串，所以在某些情况下要对字符进行**双重转义**。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如`\n`（字符`\`在字符串中通常被转义为`\\`，而在正则表达式字符串中就
会变成`\\\\`）

**但是！**，第二种方法可以用来字符串拼接。：

``` 
/* 
* 匹配第一个"bat"或"cat"，不区分大小写 
*/ 
var pattern1 = /[bc]at/i; 
 
/* 
* 与 pattern1 相同，只不过是使用构造函数创建的 
*/ 
var pattern2 = new RegExp("[bc]at", "i"); 
```


#### 5.2.1 标志

- `\g`：表示全局模式，即模式被应用于所有字符串，而非在发现第一个匹配项时立即停止。
- `\i`：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；  
- `\m`：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。 
- `\u`，unicode模式，启用unicodeP匹配。



#### 5.2.2 RegExp实例方法 

`RegExp` 对象的主要方法是`exec()`，该方法是专门为捕获组而设计的。`exec()`接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 `null`。返回的数组虽然是Array的实例，但包含两个额外的属性：`index` 和 `input`。其中，`index`表示匹配项在字符串中的位置，而 `input` 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。

```javascript
let text = "这一切全部是你咎由自取"; 
let pattern = /这(一切全部是(你咎由自取)?)?/gi; 
 
let matches = pattern.exec(text); 
alert(matches.index);     // 0 
alert(matches.input);     // 这一切全部是你咎由自取 
alert(matches[0]);        // 这一切全部是你咎由自取 
alert(matches[1]);        // 一切全部是你咎由自取
alert(matches[2]);        // 你咎由自取 
```

>  关于捕获组的更多说明详情请参考python与正则表达式以及正则表达式部分。
>
> 以上程序中，返回的数组虽然是 Array 的实例，但包含两个额外的属性：`index` 和 `input`。`index` 是字符串中匹配模式的起始位置，`input` 是要查找的字符串。

注意：对于 `exec()`方法而言，即使在模式中设置了全局标志（`g`），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用`exec()`将始终返回第一个匹配项的信息。而在设置全局标志的情况下，**每次**调用`exec()`则都会在字符串中继续查找**新匹配项**。



正则表达式的第二个方法是`test()`，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回 false。



我们可以用` RegExp.$1`、`RegExp.$2`…`RegExp.$9`，分别用于存储第一、第二……第九个匹配的捕获组。



除开以上两种方法外，还有：

- 查找：`search()`
- 提取：`match()`
- 替换：`replace()`  

### 5.3 原始值包装类型

为了方便操作原始值，ECMAScript提供了 3种特殊的引用类型：`Boolean`、`Number` 和 `String`。
这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的
各种方法。来看下面的例子： 

```javascript
let s1 = "some text"; 
let s2 = s1.substring(2); 
```

在这里， `s1`是一个包含字符串的变量，它是一个原始值。第二行紧接着在`s1`上调用了`substring()`
方法，并把结果保存在 `s2` 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问 `s1` 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3步： 

1. 创建一个 String 类型的实例； 
2. 调用实例上的特定方法； 
3. 销毁实例。 

可以把这 3步想象成执行了如下 3行 ECMAScript代码： 

```javascript
let s1 = new String("some text"); 
let s2 = s1.substring(2); 
s1 = null; 
```

这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3步也会在后台发生，只不过
使用的是 `Boolean` 和 `Number` 包装类型而已。 

#### 5.3.1  `Boolean` 

#### 5.3.2 `Number`

`isInteger()`方法

ES6新增了 `Number.isInteger()`方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0
可能会让人误以为数值是一个浮点值： 

```javascript
console.log(Number.isInteger(1));    // true 
console.log(Number.isInteger(1.00)); // true 
console.log(Number.isInteger(1.01)); // false 
```

#### 5.3.3 String

##### 5.3.3.1 `charAt()`方法和`length()`方法

`charAt()`方法返回给定索引位置的字符。这个方法查找指定索引位置的16码元，16位只能唯一表示65536个字符，如果要表示更多的字符，`charAt()`方法会带来一些问题：

```javascript
let message = "ab☺de"; 

console.log(message.length);          // 6 
console.log(message.charAt(1));       // b 

console.log(message.charAt(2));       // <?> 
console.log(message.charAt(3));       // <?> 
console.log(message.charAt(4));       // d 

console.log(message.charCodeAt(1));   // 98 
console.log(message.charCodeAt(2));   // 55357 
console.log(message.charCodeAt(3));   // 56842 
console.log(message.charCodeAt(4));   // 100 
```

##### 5.3.3.2 字符串操作方法

###### 拼接字符串

`concat()`，用于将一个或多个字符串拼接成一个新字符串。

```javascript
let stringValue = "hello "; 
let result = stringValue.concat("world"); 

console.log(result);      // "hello world" 
console.log(stringValue); // "hello" 

//可以一次传递多个参数

let result2 = stringValue.concat("world", "!"); 
 
console.log(result2);      // "hello world!" 
```

不过，我们一般更为推荐使用`+`号操作符。

###### 提取字符串

```javascript
let stringValue = "hello world"; 
console.log(stringValue.slice(3));       // "lo world" 
console.log(stringValue.substring(3));   // "lo world" 
console.log(stringValue.substr(3));      // "lo world" 
console.log(stringValue.slice(3, 7));    // "lo w" 
console.log(stringValue.substring(3,7)); // "lo w" 
console.log(stringValue.substr(3, 7));   // "lo worl" 

console.log(stringValue.slice(-3));         // "rld" 
console.log(stringValue.substring(-3));     // "hello world" 
console.log(stringValue.substr(-3));        // "rld" 
console.log(stringValue.slice(3, -4));      // "lo w" 
console.log(stringValue.substring(3, -4));  // "hel" 
console.log(stringValue.substr(3, -4));     // "" (empty string) 
```

在这个例子中，`slice()`、`substr()`和 `substring()`是以相同方式被调用的，而且多数情况下返
回的值也相同。如果只传一个参数 3，则所有方法都将返回"lo world"，因为"hello"中"l"位置为 3。
如果传入两个参数 3 和 7，则 `slice()`和 `substring()`返回"lo w"（因为"world"中"o"在位置 7，
不包含），而 `substr()`返回"lo worl"，因为第二个参数对它而言表示返回的字符数。 

在给 `slice()`和 `substr()`传入负参数时，它们的返回结果相同。这是因为-3 会被转换为 8（长度加上负参数，倒过来取，相当于python的反切片操作），而substring()方法返回整个字符串，因为-3 会转换为 0。 

**总结**来说：

- slice对应的是python的切片操作，第二个参数表示要截取到哪一个字符，为负数时视为反切片。
- substring面对所有负参数都将其视为0，当第二个参数比第一个参数小时，会和其他方法一样把它们交换。
- substr的第二个参数表示要保留多少个字符，其他和slice相同。

###### 字符串位置

有两个方法用于在字符串中定位子字符串：`indexOf()`和 `lastIndexOf()`。这两个方法从字符
串中搜索传入的字符串，并返回位置（如果没找到，则返回-1） 。两者的区别在于，`indexOf()`方法
从字符串开头开始查找子字符串，而 `lastIndexOf()`方法从字符串末尾开始查找子字符串。来看下面
的例子： 

```javascript
let stringValue = "hello world"; 
console.log(stringValue.indexOf("o"));     // 4 
console.log(stringValue.lastIndexOf("o")); // 7 

//可以接受第二个参数，表示开始搜索的位置

console.log(stringValue.indexOf("o", 6));     // 7 
console.log(stringValue.lastIndexOf("o", 6)); // 4 
```

###### 字符串包含

ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：`startsWith()`、
`endsWith()`和 `includes()`。`startsWith()`和 `includes()`方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。`endsWith()`方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样。这三个方法的使用和他们的命名一样简单，不赘述。

###### `trim()`方法

这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。与python的`strip()`方法非常类似，后者可以传入参数，表示删除其他字符。

###### `repeat()`方法

如同字面意义表示。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。

###### `padStart()`和 `padEnd()`方法 

`padStart()`和 `padEnd()`方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至
满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格。 可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。 

```javascript
let stringValue = "foo"; 

console.log(stringValue.padStart(6));       // "   foo" 
console.log(stringValue.padStart(9, "."));  // "......foo" 

console.log(stringValue.padEnd(6));         // "foo   " 
console.log(stringValue.padEnd(9, "."));    // "foo......" 

console.log(stringValue.padStart(8, "bar")); // "barbafoo" 
console.log(stringValue.padStart(2));        // "foo" 
 
console.log(stringValue.padEnd(8, "bar"));   // "foobarba" 
console.log(stringValue.padEnd(2));          // "foo" 
```

###### 字符串迭代与结构

字符串的原型上暴露了一个`@@iterator` 方法，表示可以迭代字符串的每个字符。在 `for-of` 循环中可以通过这个迭代器按序访问每个字符： 

```javascript
for (const c of "abcde") { 
  console.log(c); 
}  

// a 
// b 
// c 
// d 
// e 
```

###### 字符串大小写转换

包括 4 个方法：`toLowerCase()`、`toLocaleLowerCase()`、`toUpperCase()`和`toLocaleUpperCase()`。 `toLowerCase()`和`toUpperCase()`方法是原来就有的方法，
与`java.lang.String` 中的方法同名。 `toLocaleLowerCase()`和`toLocaleUpperCase()`方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语） ，Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。

###### 字符串模式匹配

String 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是 `match()`方法，这个方
法本质上跟 `RegExp` 对象的 `exec()`方法相同。`match()`方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 `RegExp` 对象。来看下面的例子： 

```javascript
let text = "cat, bat, sat, fat"; 
let pattern = /.at/; 
 
// 等价于 pattern.exec(text) 
let matches = text.match(pattern); 
console.log(matches.index);      // 0 
console.log(matches[0]);         // "cat" 
console.log(pattern.lastIndex);  // 0 
```

另一个查找模式的字符串方法是 `search()`。这个方法唯一的参数与 `match()`方法一样：正则表达
式字符串或 `RegExp` 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。 `search()`始终从字符串开头向后匹配模式。看下面的例子： 

```javascript
let text = "cat, bat, sat, fat"; 
let pos = text.search(/at/); 
console.log(pos);  // 1 
```

这里，`search(/at/)`返回 1，即"at"的第一个字符在字符串中的位置。 

为简化子字符串替换操作，ECMAScript提供了 `replace()`方法。这个方法接收两个参数，第一个
参数可以是一个 `RegExp` 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么**只会替换第一个子字符串**。要想替换所有子字符串，第一个参数必须为正则表达式并且**带全局标记**，如下面的例子所示： 

```javascript
let text = "cat, bat, sat, fat"; 
let result = text.replace("at", "ond"); 
console.log(result);  // "cond, bat, sat, fat" 

result = text.replace(/at/g, "ond"); 
console.log(result);  // "cond, bond, sond, fond" 
```

可以使用`$n`这样的字符串序列来表示之前捕获到的内容，类似python的`group(n)`。

```javascript
let text = "cat, bat, sat, fat"; 
result = text.replace(/(.at)/g, "word ($1)"); 
console.log(result);  // word (cat), word (bat), word (sat), word (fat) 
```

注意：上述程序中带有全局标记，如果没有全局标记，那么输出则是`word (cat), bat, sat, fat`。

`replace()`的第二个参数可以是一个函数。使用函数作为第二个参数可以更细致地控制替换过程，如下所示： 

```javascript
function htmlEscape(text) { 
  return text.replace(/[<>"&]/g, function(match, pos, originalText) { 
    switch(match) {  
      case "<": 
        return "&lt;"; 
      case ">": 
        return "&gt;"; 
      case "&": 
        return "&amp;"; 
      case "\"": 
        return "&quot;"; 
    } 
  }); 
} 
```

这里，函数 `htmlEscape()`用于将一段 HTML中的 4个字符替换成对应的实体：小于号、大于号、
和号，还有双引号（都必须经过转义）。实现这个任务最简单的办法就是用一个正则表达式查找这些字符，然后定义一个函数，根据匹配的每个字符分别返回特定的 HTML实体。 



最后一个与模式匹配相关的字符串方法是 `split()`。这个方法会根据传入的分隔符将字符串拆分成
数组。（与python的`split()`方法如出一辙。）

###### `localeCompare()`方法

比较两个字符串，按照字母表顺序，在前则返回1，相同返回0，在后返回-1。

### 5.4 单例内置对象

#### 5.4.1 Global

`encodeURI()`和 `encodeURIComponent()`方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI不能包含某些字符，比如空格。使用 URI编码方法来编码 URI可以让浏览器能够理解它们，
同时又以特殊的 UTF-8编码替换掉所有无效字符。 

这两个方法的主要区别是，`encodeURI()`不会编码属于 URL组件的特殊字符，比如冒号、斜杠、问号、井号，而 `encodeURIComponent()`会编码它发现的所有非标准字符。来看下面的例子： 

```javascript
let uri = "http://www.wrox.com/illegal value.js#start"; 

// "http://www.wrox.com/illegal%20value.js#start" 
console.log(encodeURI(uri)); 

// "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start" 
console.log(encodeURIComponent(uri));
```

注意 ：一般来说，使用 `encodeURIComponent()`应该比使用 `encodeURI()`的频率更高，这是因为编码查询字符串参数比编码基准 URI的次数更多。 而与与`encodeURI()`和`encodeURIComponent()`相对的是`decodeURI()`和`decodeURIComponent()`。

最后一个方法可能是整个 ECMAScript 语言中最强大的了，它就是 `eval()`。这个方法就是一个完
整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 `ECMAScript（JavaScript）`字符串。来看一个例子： 

```javascript
eval("console.log('hi')"); 
//等价于
console.log("hi"); 
```

这个方法非常危险，因为常常用于网络攻击中。

global对象中另外一个非常出名的是window对象，而这个会在以后详细说明。

#### 5.4.2 Math

略，建议需要用到的时候查阅。c.f.158

### 5.5 小结

JavaScript中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。 

- 引用值与传统面向对象编程语言中的类相似，但实现不同。 
- Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。 
- RegExp 类型是 ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表
  达式功能。 



JavaScript 比较独特的一点是，函数实际上是 Function 类型的实例，也就是说函数也是对象。因
为函数也是对象，所以函数也有方法，可以用于增强其能力。 

由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类
型：`Boolean`、`Number` 和 `String`。它们都具备如下特点。 

- 每种包装类型都映射到同名的原始类型。 
- 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相
  应的数据。 
- 涉及原始值的语句执行完毕后，包装对象就会被销毁。 



当代码开始执行时，全局上下文中会存在两个内置对象：`Global` 和 `Math`。其中，`Global` 对象在
大多数 ECMAScript实现中无法直接访问。不过，浏览器将其实现为 `window` 对象。所有全局变量和函
数都是 Global 对象的属性。`Math` 对象包含辅助完成复杂计算的属性和方法。 

